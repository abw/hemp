An incomplete list of things TODO, in no particular order.

* decide on a _FUNC suffix or otherwise and apply consistently, e.g.
  HEMP_GRAMMAR() vs HEMP_PREFIX()

* There's still a bunch of components with init() methods which need
  changing to new() for consistency with new naming standard.
 
* Add pairs method (%stuff) and items/fetch_all (@stuff)

* Add parse_body() method and change those elements currently using 
  parse_block.  Add default handler that returns self (single expression
  body) and block-slurping handlers for "{...}", ";...;end" and 
  "%]...[% end %]".  UPDATE: added parse_body() and applied to sub and 
  apply elements.  Needs changing in some other elements.
  
* Add sigils

* Add parallel assignment: @foo = @bar, (a, b, c) = (1, 2, 3)

* Add @list and %hash items to prototypes.

* Add arrows.  a => 10, b -> 10

* hemp_test_plan_p vs hemp_test_plan()

* hemp_element_parse_block() and various other methods need access to the 
  elements factory.  I think this should probably be encapsulated in the 
  scope object.

* double quoted string should accept embedded variables.

* Control tags and double quoted strings need to have tokens hanging off
  a BRANCH (or we need to figure out a different way to skin this cat 
  compared to how the Perl TT3 prototype works).  next() might need to 
  become a method dispatched via the element vtable.

* Figure out what needs to go into the element data structure value union
  to represent all the various different element types.

* This is my first time using autotools, and I'm sure I've made plenty of
  nooby mistakes.  The whole autoconf/automake/libtool setup needs cleaning
  up, ideally by someone more familiar with the tools than me

* filesystem is a quick hack... needs doing properly

* Factory used named passed as argument to cache instance in hash.  We
  can't guarantee that it's statically allocated.  Previous we used the 
  allocated name in, e.g. dialect->name. UPDATE: now we can use tagged 
  values.

* Figure out a nice way to implement exceptions.  Ideally we want the 
  flexibility of the Perl/Badger approach that allows a main error type to
  be defined (e.g. parse error), along with sub-type and any arguments.
  This should result in a nice error message being generated from the 
  type/subtype and args.  UPDATE: got some of the way there with hemp_throw()
  and hemp_error_init() functions.  Now need to be able to add things like
  source position / scope for parse errors.

* Add a fallback mechanism to the various factories.  e.g. if a tt3 dialect
  is requested and not found then the fallback should call hemp_language_instance("tt3")
  to give it a chance to load it.  Just got to be careful we don't end up in
  a deathly spiral if we then re-attempt the lookup and it fails again.

* Perl CODE

* change function names in type/* from hemp_value_XXX_YYY to hemp_type_XXX_YYY

* boolean vs truth: decide on the best terminology and stick to it.

* Clean up all the macros and inline functions so that they're consistently
  name, e.g. HEMP_IS_NUM() and so on.  Change 'num' to 'number' and so on.

* Number ops:
   - Add ++ and -- auto-increment operator

* Text ops:
   - textify prefix operator: ~

* figure out what to do with number/integer operators that return boolean
  values (e.g. less than).  Is it an error to ask for those as int/num?
  I think so...

* figure out how to scan/parse items.1.2.3 and not have the scanner parse
  it as (items).(1.2).3 (with a float in the middle)
  
* Create view object to walk element tree using symbol->namespace->id,
  following parent. (first attempt done, needs more work)

* Change grammar definitions to fit hierarchy corresponding to operator type
  e.g. hemp.operator.binary.number.add allows a single view method to be
  defined for hemp.operator.binary which renders all binary operators using
  a similar process (e.g.for syntax highlighting)

* Extend parse_fixed() to lookahead and merge with other fixed items 
  (equivalent to filename in TT3).  No... hang on, that's a different
  thing - we want filenames (uris) to be greedy, but a single fixed value
  after a dotop should not be.

* element->next pointers could be broken by recent change to add 
  synthesised elements on the end, after EOF.  But there are places that 
  skip down the next chain and could possibly bypass EOF.

* Add support for literal elements (other than word and number) being used
  as fixed tokens (merge/refactor token, source, etc., at the same time).

* Pre-defined symbols like start_tag and end_tag should be bound to a grammar
  so we don't get exceptions like when parse_block() wants to create a new
  block element and needs an elements reference (which includes needing a 
  grammar reference along the way).  Tags should pre-match the start_tag/end_tag
  symbols via the grammar.

* The current implementation for function parameters using context, frame
  and params results in all parameters for a function becoming global 
  dynamic variable in the current context.  It's all a bit of a mess and
  needs a bit of a re-think.

* Dynamic module loading.  Got a basic working implementation using dlopen(),
  and friends, but it needs generalising for other platforms and making more
  robust.  Also need to figure out how to construct the Makefiles using 
  autotools or by rolling yer own.

* MD5 implementation is broken.  It broke after changing hemp_char from 
  'unsigned char' to 'char' but I think it was broken before that as it was
  generating different results to other implementations.  Try Peter Deutsch's
  implementation.  NOTE: I changed hemp_char back to unsigned char because
  I originally set it that way for a reason (the reason being utf8).

* Improve URI parsing to handle incremental matching during scanning phase.
  UPDATE: nah, that's not going to work - see NOTES in uri.c

* Figure out how to represent parameters with multiple values in uri.c

* Percent encoding for URIs, implemented as a codec module

* Might want to add name parameter to module binder function so that we
  can do the equivalent of "use x as y".  Hmm... although I suppose the 
  names that it registers are supposed to be namespaced and unique. Hmm.

* HEMP_ACTION

* Rewrite HEMP_PREFIX_PRECEDENCE, etc., so they don't rely on 'type'

* Clean up scanner errors, number parse errors, etc., including quoted strings
  UPDATE: scanner errors (e.g. in quoted.c) have been cleaned up, and errors
  have been improved a little.  But there's more that can be done.  In particular
  I want to switch to a namespace-based error type, e.g. hemp.error.scan.whatever.
  That gives us the built-in walk-up mechanism for matching against more general
  type handler, and it also gives us a unique id that we can use to jump with.
  A namespace-based solution also makes it easier to render error messages from
  templates, e.g. /path/to/hemp/templates/hemp/error/scan/whatever


Configuration, Build and Installation
-------------------------------------

* Find some way to generate the relevant items hard-coded package details
  without referencing the values defined in config.h.  We don't want to 
  install the generated config.h with hemp or require end users to use it.
  But we need some of the definitions contained therein.
  
  See include/hemp/defines.h and include/hemp/config.h


Data Structures
---------------

Some other data structure we might want to add:

* IP V4/V6 addresses (used in full uri parsing)

    struct hemp_ipv4 {
        hemp_uchar octet[4];             /* 1 bytes per octet */
    }

    struct hemp_ipv6 {
        hemp_uchar data[16];            /* 2 bytes per quad */
        // or 
        hemp_quad  quad[8];
    }


Hot Stack
---------

A reminder of what I'm working towards right now...

Hemp config.  Any value with fetch() method.

config_file reads config from document using default data dialect, e.g. json

  hemp.config.file
  hemp.config.dialect

  hemp.data.path
  hemp.data.dialect

  hemp.document.path
  hemp.document.dialect

  etc

Let's start by making json a plugin language and have it autoload...[DONE]

Then create a JSON codec to read JSON data.

Rendering error messages via templates.